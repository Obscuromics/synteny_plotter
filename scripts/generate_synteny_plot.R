# cutoff of block in terms of same strand and stuff, and distance until next ortholog

suppressPackageStartupMessages(library("argparse"))
suppressPackageStartupMessages(library("dplyr"))

parser <- ArgumentParser()
parser$add_argument("-busco1",
                    help="Busco \"full_table.tsv\" of the reference (top) species")
#parser$add_argument("-busco2", 
#                    help="Busco \"full_table.tsv\" of the bottom species")
parser$add_argument("-chrom1", 
                    help="A .tsv table with chromosomes of the reference species (4 columns expected chromosome, length, order, direction)")
parser$add_argument("-busco_list", 
                    help="A list of Busco \"full_table.tsv\" of the one or more query species ")
parser$add_argument("-chrom_list", 
                    help="A list of .tsv tables with chromosomes of the one or more query species (4 columns expected chromosome, length, order, direction)")
parser$add_argument("-o", "--output_prefix", default = "synteny_plot",
                    help="Name pattern for the output")
parser$add_argument("-g", "-gap", type = "integer",
                    help="Gap between two chromosomal sets")
parser$add_argument("-f", "-filter", type = "integer",
                    help="The minimal number of BUSCOs on a chromosome to include")
parser$add_argument("-alpha", type = "integer", default = 0,
                    help="Set transparency to colours [%]")
args <- parser$parse_args()
source('scripts/interactive_args.R')

### specify arguments ###
minimum_buscos <- args$filter
busco1 <- args$busco1
if (length(busco_list) == 1){ # i.e. if running from command line - need to make a list from the inputed file name(s)
  busco_list <- strsplit(args$busco_list, " ")[[1]]
  chrom_list <- strsplit(args$chrom_list, " ")[[1]]
}

#busco2 <- args$busco2
#busco3 <- args$busco3
# gap <- args$gap
chrom1 <- args$chrom1 # REF
#chrom2 <- args$chrom2 # QEURY
#chrom3 <- args$chrom3

# minimum_buscos <- args$filter
# output_prefix <- args$output

source('scripts/helper_functions.R') # import functions


### specify parameters
gap=6
show_outline = TRUE
chr_offset = 20000000 # TODO make this automatically a prop of chr length

### read in data ###

# TODO: allow for algs in the arguments
# algs <- read.csv(args$alg_file, sep='\t', header=FALSE)[,c(1,3)]
# colnames(algs) <- c('busco', 'alg')
# alignments <- merge(alignments, algs, by='busco')

R_df <- read_buscos(args$busco1, 'R')
#Q_df <- read_buscos(args$busco2, 'Q') 
R_chromosomes <- read.table(args$chrom1, sep = '\t', header = TRUE)
#Q_chromosomes <- read.table(args$chrom2, sep = '\t', header = TRUE)
R_chromosomes <- R_chromosomes %>% arrange(order)

make_alignment_table <- function(R_df, R_chromosomes, Q_df, Q_chromosomes){
  alignments <- merge(Q_df, R_df, by='busco')
  # apply any filters
  alignments <- alignments %>% group_by(chrR) %>% filter(n() > minimum_buscos) %>% ungroup()
  R_chromosomes <- R_chromosomes %>% filter(chr %in% alignments$chrR)  
  Q_chromosomes <- Q_chromosomes %>% filter(chr %in% alignments$chrQ) 
  R_chromosomes <- R_chromosomes %>% arrange(order)
  chr_order_R <- R_chromosomes$chr # extract order of chr
  Q_chromosomes <- Q_chromosomes %>% arrange(order)
  chr_order_Q <- Q_chromosomes$chr #extract order of chr
  # print(Q_chromosomes)
  # print(chr_order_Q)
  print('R_chr:') 
  print(R_chromosomes)
  print('chr_order_R')
  print(chr_order_R)
  alignments$alg <- NA
  alignments <- perform_inverts(alignments, Q_chromosomes) 
  offset_alignments_Q <- offset_chr(alignments, 'Q', chr_offset, chr_order_Q)
  offset_alignments_RQ <- offset_chr(offset_alignments_Q$df, 'R', chr_offset, chr_order_R)
  alignments <- offset_alignments_RQ$df
  offset_list_R <- offset_alignments_RQ$offset_list
  offset_list_Q <- offset_alignments_Q$offset_list
  output_list <- list('alignments' = alignments, 'chr_order_R' = chr_order_R, 'chr_order_Q'=chr_order_Q,
                      'offset_list_R'=offset_list_R, 'offset_list_Q'=offset_list_Q)
  return(output_list)
}

counter = 1
max_ends <- list()
max_chr_set <- 'R'
processed_Q_list <- list()

for (i in args$busco_list){
  temp_R_chromosomes <- R_chromosomes
  Q_df <- read_buscos(i, 'Q')  
  Q_chromosomes <- read.table(args$chrom_list[counter], sep = '\t', header = TRUE)
  # the following three lines have been commented out as now query_chr_file is now generated with an auto order based on 'dev_generate_chromosome_file.R' before running this script
  #Q_chromosomes_auto <- generate_auto_query_order(temp_R_chromosomes, R_df, Q_df) # - maybe the function needs to be a bit adjusted
  #Q_chromosomes <- Q_chromosomes_auto
  #print(Q_chromosomes_auto)
  # print("ORIGINAL:")
  # print(head(Q_chromosomes))
  # print("AUTOGENERATED:")
  # print(head(Q_chromosomes_auto))
  processed_Q <- make_alignment_table(R_df, temp_R_chromosomes, Q_df, Q_chromosomes)
  alignments <- processed_Q$alignments
  # print(i)
  # print(head(alignments))
  processed_Q_list <- append(processed_Q_list, processed_Q)
  counter = counter + 1
  max_ends <- append(max_ends, max(alignments$Rend))
  max_ends <- append(max_ends, max(alignments$Qend))
  R_df <- Q_df # Q1 becomes ref for next iteration (Q2)
  colnames(R_df) <- c('busco', 'chrR', 'Rstart', 'Rend', 'Rstrand')
  temp_R_chromosomes <- Q_chromosomes
}



max_end <- max(unlist(max_ends))
plot_length <- max_end # make plot_length the max of the longest chr set

pdf(paste0(args$output_prefix, '.pdf'))
plot(0,cex = 0, xlim = c(1, plot_length), ylim = c(((gap+1)*-1*length(args$busco_list)*2),((gap+1)*length(args$busco_list)*2)), xlab = "", ylab = "", bty = "n", yaxt="n", xaxt="n")

if (nrow(R_chromosomes) <= 6){
  col_list <- c("#ffc759","#FF7B9C", "#607196", "#BABFD1", '#BACDB0', '#C6E2E9', '#F3D8C7')
} else { col_list <- c('#577590', '#617A8B', '#6B8086', '#748581', '#7E8A7C', '#889077', '#929572', '#9B9A6D',
                       '#A5A068', '#AFA563', '#B9AA5E', '#C2AF59', '#CCB554', '#D6BA4F', '#E0BF4A', '#E9C545', 
                       '#F3CA40', '#F1C544', '#EFC148', '#EDBC4C', '#EBB84F', '#E9B353', '#E7AF57', '#E5AA5B',
                       '#E3A55F', '#E1A163', '#DF9C67', '#DD986A', '#DB936E', '#D98F72', '#D78A76')
}

if (nrow(R_chromosomes) > 31){
col_list <- c('#577590', '#617A8B', '#6B8086', '#748581', '#7E8A7C', '#889077', '#929572', '#9B9A6D',
              '#A5A068', '#AFA563', '#B9AA5E', '#C2AF59', '#CCB554', '#D6BA4F', '#E0BF4A', '#E9C545', 
              '#F3CA40', '#F1C544', '#EFC148', '#EDBC4C', '#EBB84F', '#E9B353', '#E7AF57', '#E5AA5B',
              '#E3A55F', '#E1A163', '#DF9C67', '#DD986A', '#DB936E', '#D98F72', '#D78A76','#577590', 
              '#617A8B', '#6B8086', '#748581', '#7E8A7C', '#889077', '#929572', '#9B9A6D',
              '#A5A068', '#AFA563', '#B9AA5E', '#C2AF59', '#CCB554', '#D6BA4F', '#E0BF4A', '#E9C545', 
              '#F3CA40', '#F1C544', '#EFC148', '#EDBC4C', '#EBB84F', '#E9B353', '#E7AF57', '#E5AA5B',
              '#E3A55F', '#E1A163', '#DF9C67', '#DD986A', '#DB936E', '#D98F72', '#D78A76')
}

num_remove <- length(col_list) - nrow(R_chromosomes) 
print(num_remove)
set.seed(123) # set a random seed for reproducibility
indices_to_remove <- sample(length(col_list), num_remove) # get random indices of elements to remove
my_list_cleaned <- col_list[-indices_to_remove] # remove elements from the list using negative indexing

col_list <- sapply(col_list, t_col, args$alpha)


main_counter <- 1
y_offset <- 0
y_increment <- 17
for (i in args$busco_list){
  # print(i)
  # print(tail(alignments))
  alignments <- processed_Q_list[[main_counter]]
  chr_order_R <- processed_Q_list[[main_counter+1]]
  chr_order_Q <- processed_Q_list[[main_counter+2]]
  print(chr_order_R)
  offset_list_R <- processed_Q_list[[main_counter+3]]
  offset_list_Q <- processed_Q_list[[main_counter+4]]
  
  if (max(alignments$Qend) != max_end){ # i.e. if this is the longest chr_set
    if (max(alignments$Rend) != max_end){
      adjustment_length_R <- (max_end - max(alignments$Rend)) / 2 
      adjustment_length_Q <- (max_end - max(alignments$Qend)) / 2 
    }
    else{
      adjustment_length_R <- 0
      adjustment_length_Q <- (max_end - max(alignments$Qend)) / 2 
    }
  }
  else{
    adjustment_length_Q <- 0
    adjustment_length_R <- (max_end - max(alignments$Rend)) / 2 
  }
  counter <- 1
  for (i in chr_order_R){
      temp <- alignments[alignments$chrR == i,]
      #plot_one_ref_chr(temp, col_list[[counter]], "red", adjustment_length_R, adjustment_length_Q, y_offset) # use this if want to colour inverted genes in red
      plot_one_ref_chr(temp, col_list[[counter]], col_list[[counter]], adjustment_length_R, adjustment_length_Q, y_offset)
      counter <- counter + 1
  }
  
  counter <- 1  # chr outlines for query
  for (i in chr_order_Q){
      temp <- alignments[alignments$chrQ == i,]
      Qfirst <- min(temp$Qstart)
      Qlast <- max(temp$Qend)
      segments(Qfirst+adjustment_length_Q, 1-gap-y_offset, Qlast+adjustment_length_Q, 1-gap-y_offset, lwd = 5)
    }
  
  counter <- 1   # chr outlines for ref
  for (i in chr_order_R){
    temp <- alignments[alignments$chrR == i,]
    Rfirst <- min(temp$Rstart)
    Rlast <- max(temp$Rend)
    segments(Rfirst+adjustment_length_R, gap-y_offset, Rlast+adjustment_length_R, gap-y_offset, lwd = 5)
  }
  
  if (main_counter == 1){ # only need to plot text labels ref if this is the first chr set being plotted, else get duplicates
    counter <- 1    # text labels for ref
    for (i in chr_order_R){
      temp <- alignments[alignments$chrR == i,]
      Rfirst <- min(temp$Rstart)
      Rlast <- max(temp$Rend)
      offset <- offset_list_R[[counter]]
      text(x = ((Rlast+Rfirst+1)/2)+adjustment_length_R, y = gap+3.5, label = i,
           srt = 90, cex=0.5) # Rotation
      counter <- counter + 1
    }
  }

  counter <- 1  # text labels for query:
  for (i in chr_order_Q){
      temp <- alignments[alignments$chrQ == i,]
      Qfirst <- min(temp$Qstart)
      Qlast <- max(temp$Qend)
      text(x = ((Qlast+Qfirst+1)/2)+adjustment_length_Q, y = -gap-2-y_offset, label = i,
           srt = 90, cex=0.5) # Rotation
      counter <- counter + 1
  }
  main_counter <- main_counter + 5
  y_offset <- y_offset + y_increment
  }

#dev.off()

main_counter <- 1
for (i in args$busco_list){
  alignments <- processed_Q_list[[main_counter]]
  chr_order_R <- processed_Q_list[[main_counter+1]]
  chr_order_Q <- processed_Q_list[[main_counter+2]]
  offset_list_R <- processed_Q_list[[main_counter+3]]
  offset_list_Q <- processed_Q_list[[main_counter+4]]
  main_counter <- main_counter + 5
  # print(chr_order_R)
}

# seems order in Q_chromosomes is obeyed when the species is the reference but not when its the query

# if we start saving the tabs, something like this works well
# write.table(chromosomal_correspondences, 'test_data/Vanessa_cardui_info_generated.tsv', sep = '\t', row.names = FALSE, col.names = TRUE, quote = FALSE)


# 1.) determine diominant (mode) ref chr per query chr - use as order i.e. assuming ref is fixed
# 2.) sort groups of query that map to same ref by average ref start
# 3.) calculate correlation - if negative, invert
# 4.) output settings table

# TODO - change input table to be one per run rather than one per species, means adding a species column

for (i in args$busco_list){
  # print(i)
  # print(tail(alignments))
  alignments <- processed_Q_list[[main_counter]]
  chr_order_R <- processed_Q_list[[main_counter+1]]
  chr_order_Q <- processed_Q_list[[main_counter+2]]
  offset_list_R <- processed_Q_list[[main_counter+3]]
  offset_list_Q <- processed_Q_list[[main_counter+4]]
  
  
  plot(0,cex = 0, xlim = c(1, plot_length), ylim = c(((gap+1)*-1*length(args$busco_list)*2),((gap+1)*length(args$busco_list)*2)), xlab = "", ylab = "", bty = "n", yaxt="n", xaxt="n")
  
  main_counter <- 1
  y_offset <- 0
  y_increment <- 17
  for (i in args$busco_list){
    # print(i)
    # print(tail(alignments))
    alignments <- processed_Q_list[[main_counter]]
    chr_order_R <- processed_Q_list[[main_counter+1]]
    chr_order_Q <- processed_Q_list[[main_counter+2]]
    offset_list_R <- processed_Q_list[[main_counter+3]]
    offset_list_Q <- processed_Q_list[[main_counter+4]]
    
  counter <- 1  # chr outlines for query
  for (i in chr_order_Q){
    temp <- alignments[alignments$chrQ == i,]
    Qfirst <- min(temp$Qstart)
    Qlast <- max(temp$Qend)
    segments(Qfirst+adjustment_length_Q, 1-gap-y_offset, Qlast+adjustment_length_Q, 1-gap-y_offset, lwd = 5)
  }
  main_counter <- main_counter + 5
  y_offset <- y_offset + y_increment
}
